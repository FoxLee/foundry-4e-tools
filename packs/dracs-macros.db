{"_id":"1G5CG8XMohEsrFn0","name":"Item: Auto Roll Power","type":"script","author":"MZbxT6Tw0ZjDJstw","img":"icons/svg/d20.svg","scope":"global","command":"// This macro is designed to go into a power to accelerate rollign things into chat\n// If you also want the text dialog, set it to run after, if you want no extra text, set it to run as substitute\n// If you want the dialogs to appear so you can add conditions, edit the code to be const event = { shiftKey: false }\n// Remember:\n// this.item = the item\n// this.actor = the actor\n\n\nconst item = this.item\nconst event = { shiftKey: true }\nif (item.hasAttack) {\n    await item.rollAttack({event : event })\n}\nif (item.hasDamage) {\n    await item.rollDamage({event : event })\n}\nif (item.hasHealing) {\n    item.rollHealing({event : event })\n}","folder":null,"sort":0,"flags":{"core":{"sourceId":"Macro.BvFwevVyR5W6YHN4"}},"ownership":{"default":0,"MZbxT6Tw0ZjDJstw":3},"_stats":{"systemId":"dnd4e","systemVersion":"0.3.3","coreVersion":"10.285","createdTime":null,"modifiedTime":1663419062861,"lastModifiedBy":"MZbxT6Tw0ZjDJstw"}}
{"name":"Toggle Mark","type":"script","author":"MZbxT6Tw0ZjDJstw","img":"icons/skills/targeting/crosshair-bars-yellow.webp","scope":"global","command":"// Quick helper for GMs, will toggle a mark status effect on all the selected tokens.  \n// to see what the other status effects are you can stick CONFIG.statusEffects into the console.\n\nconst effectId = \"mark_1\"\nlet effect = CONFIG.statusEffects.find((effect) => effect.id === effectId);\nlet targets = canvas.tokens.controlled;\nfor( let i = 0; i < targets.length; i++) {\n    targets[i].toggleEffect(effect);\n}","folder":null,"sort":0,"permission":{"default":0,"MZbxT6Tw0ZjDJstw":3},"flags":{"core":{"sourceId":"Macro.DXSKVn0nKOP9Xxq9"}},"_id":"1vY02fTzzAVBpS8p"}
{"_id":"LNBYPaqygCTYOf5C","name":"Create Treasure Roll Tables","type":"script","author":"MZbxT6Tw0ZjDJstw","img":"icons/svg/dice-target.svg","scope":"global","command":"/*\nYou should never need to run this macro, you should make use of the Roll Tables for gems and art findable in the treasure compendium.  \n\nI use this to create Roll tables for various values of Gems and Art Objects\n\nTo make things a bit more varied I wrote a spreadsheet with gems (the standard ones you often see in treasure lists + others) and looked up some qualifiers like translucency and colour.  This script takes that sheet data and builds roll tables from it.  The source data I have as a pipe delimited journal entry locally - I have not supplied it.  \n\nArt objects is a double stack, it is firstly a collection of valuable objects taken from various edition SRD's, added to by random things my friends oculd think up.  Again many of the objects have different materials, that get parsed and included into the table as separate entries to make things a bit more varied.\nAs a lot of \"art\" is jewelry, and a lot of those contain gems, many of the art object entries contain the text ${gem_<value>}, for this reason you should either use my \"roll item\" macro or be prepared to make a second roll on the relevant gems table to find out what your piece of jewelry is covered in.\n*/\nconst generateGems = false;\nconst generateArt = false;\n\nif (generateGems) {\n    const srcText = game.journal.find(x => x.name === \"Gems\").data.content.replace('<p>', '').replace('</p>', '')\n    const lines = srcText.split('@')\n    const gems = {}\n    const gemIcons = {\n        25 : \"icons/commodities/gems/gem-cluster-blue-white.webp\",\n        100 : \"icons/commodities/gems/gem-rough-navette-yellow-green.webp\",\n        500 : \"icons/commodities/gems/gem-faceted-diamond-pink.webp\",\n        1000 : \"icons/commodities/gems/gem-faceted-radiant-red.webp\",\n        5000 : \"icons/commodities/gems/gem-faceted-round-white.webp\",\n    }\n\n    const folder = await Folder.create({\n        name: \"Gems\",\n        type: \"RollTable\",\n        parent: null\n    });\n\n    for (const line of lines) {\n        const parts = line.split('|')\n        let valueStr = parts[0].trim();\n        if (!valueStr) {\n            continue;\n        }\n        const value = parseInt(valueStr)\n        if (!gems[value]) {\n            gems[value] = []\n        }\n\n        const gem = parts[1];\n        const opacities = parts[2].split(',').filter(x => x.length > 0);\n        const colours = parts[3].split(',').filter(x => x.length > 0);\n\n        opacities.forEach(opacity => {\n            colours.forEach(colour => {\n                gems[value].push(`${opacity} ${colour} ${gem}`.toLowerCase())\n            })\n        })\n    }\n\n    for (const [value, gemsList] of Object.entries(gems)) {\n        const img = gemIcons[value] ? gemIcons[value] : \"icons/commodities/gems/gem-rough-oval-purple.webp\"\n        const data = {\n            name: `${value}gp Gems`,\n            description: `Gems worth ${value}gp`,\n            formula: \"1d#\",\n            replacement: true,\n            displayRoll: false,\n            folder : folder.id,\n            img,\n            results: gemsList.map(gem => { return {\n                \"type\": CONST.TABLE_RESULT_TYPES.TEXT,\n                text: gem,\n                img,\n                range: [1, 1],\n                weight: 1\n            }})\n        }\n\n        RollTable.create(data).then(table => table.normalize())\n    }\n\n    ui.notifications.info(\"Created\")\n}\n\nif (generateArt) {\n    const srcText = game.journal.find(x => x.name === \"Art\").data.content.replace('<p>', '').replace('</p>', '')\n    const lines = srcText.split('@')\n    const arts = {}\n    const artIcons = {\n        250 : \"icons/commodities/treasure/token-engraved-purple-glowing.webp\",\n        750 : \"icons/commodities/treasure/statue-gold-laurel-wreath.webp\",\n        1500 : \"icons/commodities/treasure/broach-gold-ruby.webp\",\n        2500: \"icons/commodities/treasure/mask-jeweled-gold.webp\",\n        7500: \"icons/commodities/treasure/crown-gold-satin-gems-red.webp\",\n        25000: \"icons/commodities/treasure/bust-pharaoh-gold-blue.webp\"\n    }\n\n    const folder = await Folder.create({\n        name: \"Art\",\n        type: \"RollTable\",\n        parent: null\n    });\n    const regex = /\\${gem_(\\d+)}/;\n    const gemTables = await game.packs.get(\"foundry-4e-tools.dracs_treasure\").getDocuments().then(arr => {\n        console.log(arr)\n        return arr.reduce(function(obj, doc) {\n            obj[doc.name] = doc\n            return obj\n        }, {})\n    })\n    for (const line of lines) {\n        const parts = line.split('|')\n        let valueStr = parts[0].trim();\n        if (!valueStr) {\n            continue;\n        }\n        const value = parseInt(valueStr)\n        if (!arts[value]) {\n            arts[value] = []\n        }\n\n        const item = parts[1];\n        const materials = parts[2].split(',').filter(x => x.length > 0);\n\n        let weight = 1\n        // sort materials\n        const itemMaterials = []\n        if (materials.length > 0) {\n            materials.forEach(material => {\n                itemMaterials.push(item.replaceAll('${MATERIAL}', material).toLowerCase())\n            })\n            weight = 10 // used in if later\n        }\n        else {\n            itemMaterials.push(item.toLowerCase())\n            weight = 50 //used in if later\n        }\n\n        /*\n        Weighting outcomes:\n        Assuming 4 materials\n        single material, no gems: 1 (items) * 50 (weight)\n        single material gems = 1 (items) * 5 (weight) * 10 (gems) = 50\n        multi material no gems = 4 (items) * 10 (weight) = 40\n        multi material, gems = 4 (items) * 1 (weight) * 10 (gems) = 40\n        materials will fluctuate, but most are in the 3-5 range\n         */\n\n        // add gems from placeholders\n        for (const itemMaterial of itemMaterials) {\n            let match = itemMaterial.match(regex)\n            if (match) {\n                weight = weight === 50 ? 5 : 1 // adjust weighting for if single or multi material\n                // for sanities sake, rather than every possible combination, we are running with 10\n                for (let i = 0; i < 10; i++) {\n                    let workingString = itemMaterial\n                    match = workingString.match(regex) // rerun here to reset every loop\n                    while (match && match.length > 0) {\n                        let gemValue = match[1]\n                        const gemTable = gemTables[`${gemValue}gp Gems`]\n                        const gemResult = await gemTable.roll()\n                        const gem = gemResult.results[0].data.text\n                        workingString = workingString.replace('${gem_' + gemValue + '}', gem)\n                        match = workingString.match(regex)\n                    }\n                    arts[value].push( { name: workingString, weight })\n                }\n            }\n            else {\n                arts[value].push({ name: itemMaterial, weight })\n            }\n        }\n    }\n\n    for (const [value, gemsList] of Object.entries(arts)) {\n        const img = artIcons[value] ? artIcons[value] : \"icons/commodities/treasure/figurine-idol.webp\"\n        const data = {\n            name: `${value}gp Art Objects`,\n            description: `Art Objects worth ${value}gp.`,\n            formula: \"1d#\",\n            replacement: true,\n            displayRoll: false,\n            folder : folder.id,\n            img,\n            results: gemsList.map(gemAndWeight => { return {\n                \"type\": CONST.TABLE_RESULT_TYPES.TEXT,\n                text: gemAndWeight.name,\n                img,\n                range: [1, 1],\n                weight: gemAndWeight.weight\n            }})\n        }\n\n        RollTable.create(data).then(table => table.normalize())\n    }\n\n    ui.notifications.info(\"Created\")\n}","folder":null,"sort":0,"permission":{"default":0,"MZbxT6Tw0ZjDJstw":3},"flags":{"core":{"sourceId":"Macro.9nFd7F1CRC3WcAiR"}}}
{"name":"Toggle Auras","type":"script","author":"MZbxT6Tw0ZjDJstw","img":"icons/magic/control/silhouette-hold-change-blue.webp","scope":"global","command":"// This assumes you are using Token-Auras Module\n// set whether you are updating aura1 or aura2, use the token UI to set the aura settings how you want them.\n// If you want to set the entire token-aura effect in the macro and override the UI, then you need to change the object passed\n// in the update part to look like:\n/*\n{\n    \"distance\": distance,\n    \"colour\": \"#FFFF99\",\n    \"opacity\": 0.3,\n    \"square\": true,\n    \"permission\": \"all\"\n}\n*/\n\nconst aura = \"aura1\";\nconst distance = 1\n\nconst targets = canvas.tokens.controlled;\nconst makeUpdateData = (data) => {\n    const updateData = {flags: {\"token-auras\": {}}}\n    updateData.flags[\"token-auras\"][aura] = data\n    return updateData\n};\n\nfor (let i = 0; i < targets.length; i++) {\n    if (targets[i].document.flags[\"token-auras\"]?.[aura]?.distance) {\n        const updateData = makeUpdateData({ distance: null});\n        targets[i].document.update(updateData);\n    }\n    else {\n        const updateData = makeUpdateData({ distance });\n        targets[i].document.update(updateData);\n    }\n}","folder":null,"sort":0,"flags":{"core":{"sourceId":"Macro.6VYIdvybDPptaOmZ"}},"_id":"T5EgXwfMyQmwYIqK","ownership":{"default":0,"MZbxT6Tw0ZjDJstw":3},"_stats":{"systemId":"dnd4e","systemVersion":"0.3.3","coreVersion":"10.285","createdTime":null,"modifiedTime":1663421532309,"lastModifiedBy":"MZbxT6Tw0ZjDJstw"}}
{"name":"Toggle Token Light","type":"script","author":"MZbxT6Tw0ZjDJstw","img":"icons/sundries/lights/lantern-iron-yellow.webp","scope":"global","command":"// This macro adds a specified light effect to a token\n// the effects have been chosen to closely mimic some popular D&D 4E light sources\n// Its not perfect, as foundry light is round and 4E light is technically square.  Live with it!\n// It also sets the \"torch\" status effect on the token so you know who is carrying the torch\n\n\nfunction tokenUpdate(data, active = true) {\n  let effect = CONFIG.statusEffects.find((effect) => effect.id === \"torch\");\n  let targets = canvas.tokens.controlled;\n  for( let i = 0; i < targets.length; i++) {\n    targets[i].document.update(data);\n    let existing = targets[i].actor?.effects.find(x => x.flags.core?.statusId === \"torch\");\n    if (!active || !existing) {\n       targets[i].toggleEffect(effect, {active});\n    }\n  }\n}\n\nlet torchAnimation = {\"type\": \"torch\", \"speed\": 1, \"intensity\": 1, \"reverse\": false};\n\nlet noAnimation = {\"type\": \"none\", \"speed\": 5, \"intensity\": 5, \"reverse\": false};\n\nlet dialogEditor = new Dialog({\n  title: `Token Light Picker`,\n  content: `Pick the light source the selected token is holding.`,\n  buttons: {\n    none: {\n      label: `None`,\n      callback: () => {\n        tokenUpdate({\"light.dim\": 0, \"light.bright\": 0, \"light.angle\": 360, \"light.color\":\"#ffffff\" }, false);\n        dialogEditor.render(true);\n      }\n    },\n    torch: {\n      label: `Torch`,\n      callback: () => {\n        tokenUpdate({\"light.dim\": 2, \"light.bright\": 5, \"light.angle\": 0, \"light.luminosity\": 0.5, \"light.animation\": torchAnimation, \"light.color\" : \"#ffad58\"});\n        dialogEditor.render(true);\n      }\n    },    \n    lamp: {\n      label: `Lantern`,\n      callback: () => {\n        tokenUpdate({\"light.dim\": 2, \"light.bright\": 10, \"light.angle\": 360, \"light.luminosity\": 0.5, \"light.animation\": torchAnimation, \"light.color\" : \"#eccd8b\"});\n        dialogEditor.render(true);\n      }\n    },\n    sunrod: {\n      label: `Sunrod`,\n      callback: () => {\n        tokenUpdate({\"light.dim\": 2, \"light.bright\": 20, \"light.angle\": 360, \"light.luminosity\": 0.7, \"light.animation\": torchAnimation, \"light.color\" : \"#80beff\"});\n        dialogEditor.render(true);\n      }\n    },\n    candle: {\n      label: `Candle`,\n      callback: () => {\n        tokenUpdate({\"light.dim\": 2, \"light.bright\": 0, \"light.angle\": 0, \"light.luminosity\": 0.5, \"light.animation\": torchAnimation, \"light.color\" : \"#ffad58\"});\n        dialogEditor.render(true);\n      }\n    },\n    glowbug: {\n      label: `Jar of Glowbugs`,\n      callback: () => {\n        tokenUpdate({\"light.dim\": 0.5, \"light.bright\": 0, \"light.angle\": 360, \"light.luminosity\": 0.3, \"light.animation\": torchAnimation, \"light.color\" : \"#4dd569\"});\n        dialogEditor.render(true);\n      }\n    },\n    close: {\n      icon: \"<i class='fas fa-tick'></i>\",\n      label: `Close`\n    },\n  },\n  default: \"close\",\n  close: () => {}\n});\n\ndialogEditor.render(true)","folder":null,"sort":0,"flags":{"core":{"sourceId":"Macro.mn5Tv7u1EOOnsHIy"},"scene-packer":{"sourceId":"Macro.mn5Tv7u1EOOnsHIy","defaultPermission":2}},"_id":"XUjrLhXFZPI3XBZX","ownership":{"default":0,"MZbxT6Tw0ZjDJstw":3},"_stats":{"systemId":"dnd4e","systemVersion":"0.3.3","coreVersion":"10.285","createdTime":null,"modifiedTime":1663421652262,"lastModifiedBy":"MZbxT6Tw0ZjDJstw"}}
{"name":"Required Knowledge","type":"script","author":"MZbxT6Tw0ZjDJstw","img":"icons/sundries/books/book-eye-pink.webp","scope":"global","command":"// GM utility macro: for all selected tokens will private chat message you what the difficulty DC is to make monster knowledge checks.  Giving you both the moderate and hard DC's for the appropreate level.\n// It will also attempt to give you the skill required based off the creatures origin, type and other types.  \n// If you want to customise that to deal with your own creations, add them to the knowledges object.  You'll see I have a few warforged related ones as I GM an Eberron game.  \n\nif (game.user.role < 3) {\n    ui.notifications.error(\"Macro is GM Only\")\n    return;\n}\n\nconst difficultClass = {\n    1: {easy: 8, moderate: 12, hard: 19},\n    2: {easy: 9, moderate: 13, hard: 20},\n    3: {easy: 9, moderate: 13, hard: 21},\n    4: {easy: 10, moderate: 14, hard: 21},\n    5: {easy: 10, moderate: 15, hard: 22},\n    6: {easy: 11, moderate: 15, hard: 23},\n    7: {easy: 11, moderate: 16, hard: 23},\n    8: {easy: 12, moderate: 16, hard: 24},\n    9: {easy: 12, moderate: 17, hard: 25},\n    10: {easy: 13, moderate: 18, hard: 26},\n    11: {easy: 13, moderate: 19, hard: 27},\n    12: {easy: 14, moderate: 20, hard: 28},\n    13: {easy: 14, moderate: 20, hard: 29},\n    14: {easy: 15, moderate: 21, hard: 29},\n    15: {easy: 15, moderate: 22, hard: 30},\n    16: {easy: 16, moderate: 22, hard: 31},\n    17: {easy: 16, moderate: 23, hard: 31},\n    18: {easy: 17, moderate: 23, hard: 32},\n    19: {easy: 17, moderate: 24, hard: 33},\n    20: {easy: 18, moderate: 25, hard: 34},\n    21: {easy: 19, moderate: 26, hard: 35},\n    22: {easy: 20, moderate: 27, hard: 36},\n    23: {easy: 20, moderate: 27, hard: 37},\n    24: {easy: 21, moderate: 28, hard: 37},\n    25: {easy: 21, moderate: 29, hard: 38},\n    26: {easy: 22, moderate: 29, hard: 39},\n    27: {easy: 22, moderate: 30, hard: 39},\n    28: {easy: 23, moderate: 30, hard: 40},\n    29: {easy: 23, moderate: 31, hard: 41},\n    30: {easy: 24, moderate: 32, hard: 42}\n};\n\nconst knowledges = {\n    arcana: [\"elemental\", \"fey\", \"shadow\", \"construct\", \"warforged\", \"living construct\"],\n    dungeoneering: [\"aberrant\", \"mournland\"],\n    nature: [\"natural\"],\n    religion: [\"immortal\", \"undead\"]\n};\n    \nconst knowledgesLookup = {};\nfor (const [skill, origins] of Object.entries(knowledges)) {\n    origins.forEach(origin => knowledgesLookup[origin] = skill)\n}\n\ncanvas.tokens.controlled.forEach(token => {\n    if (!token.actor) {\n        return;\n    }\n\n    const actor = token.actor;\n    const level = actor.system.details.level\n    const toCheck = []\n    if (actor.system.details.origin) {\n        toCheck.push(actor.system.details.origin)\n    }\n    if (actor.system.details.type) {\n         toCheck.push(actor.system.details.type)\n    }   \n    if (actor.system.details.other) {\n       const allOtherTypes = actor.system.details.other.toLowerCase().split(/, */)\n       toCheck.push(...allOtherTypes)\n    }\n\n    let knowledge = \"\"\n    toCheck.forEach(origin => {\n        if (knowledgesLookup[origin]) {\n            knowledge += `${knowledgesLookup[origin]} (${origin}), `\n        }\n    })\n\n    const diff = difficultClass[level]\n\n    let msg = `DC <b>${diff.moderate}</b> moderate / <b>${diff.hard}</b> hard`\n    \n    if (knowledge) {\n         // trim trailing \", \"\n        knowledge = knowledge.substring(0, knowledge.length - 2)\n        msg += `<br>Skills: ${knowledge}`\n    }\n\n    ChatMessage.create({\n        type: 4,\n        user: game.user._id,\n        speaker: ChatMessage.getSpeaker({token: actor}),\n        content: msg,\n        whisper: [game.user._id]\n    });\n })","folder":null,"sort":0,"flags":{"core":{"sourceId":"Macro.lIn8AdrvBsgiu0UY"}},"_id":"cNV7w9dicuGXylAk","ownership":{"default":0,"MZbxT6Tw0ZjDJstw":3},"_stats":{"systemId":"dnd4e","systemVersion":"0.3.3","coreVersion":"10.285","createdTime":null,"modifiedTime":1663419938606,"lastModifiedBy":"MZbxT6Tw0ZjDJstw"}}
{"_id":"uFci2E4vXrxvB5Ei","name":"Toggle Active Effect","type":"script","author":"MZbxT6Tw0ZjDJstw","img":"icons/svg/ice-aura.svg","scope":"global","command":"// From EndlessNights\n// Toggles the named effect on or off.\n// primarily designed to be used as an item macro, but can be run independently\n// if running from a token use: const effect = token.actor.effects.filter(i => i.label === effectName)[0];\nconst effectName = 'Name of Effect Here'\nconst effect = this.actor.effects.filter(i => i.label === effectName)[0];\nif(!effect) return ui.notifications.error('Error: Effect: \"' + effectName + '\" not found.');\nawait effect.update({'disabled': !effect.disabled});","folder":null,"sort":0,"flags":{"core":{"sourceId":"Macro.FscTaK9eo9X75z4c"}},"ownership":{"default":0,"MZbxT6Tw0ZjDJstw":3},"_stats":{"systemId":"dnd4e","systemVersion":"0.3.3","coreVersion":"10.285","createdTime":null,"modifiedTime":1663421262249,"lastModifiedBy":"MZbxT6Tw0ZjDJstw"}}
{"_id":"wcM61a1p3NIjbyqC","name":"Item: Heal / Add Temp HP","type":"script","author":"MZbxT6Tw0ZjDJstw","img":"icons/magic/life/heart-cross-strong-purple-orange.webp","scope":"global","command":"// Sample Item macro for abilities that provide healing.\n// Set it to execute after the item use and customise as needed\n// this calls the methods on the actor itself to calculate damage and temp hp\n// so does the heavy lifting for you\n\nconst hpValue = 5;\n\n// add temporary HP\n// this method handles all temp hp rules (max value only)\n// must await here or get concurrent issues with healing \n// could also get around this with promise chaining, but for an item macro await is easier\nawait this.actor.applyTempHpChange(hpValue);\n\n\n// apply damage to character, \n// note this is apply, it takes the value and applies it directly with the multiplier, taking account of max health and min health\n// it does not handle resistances/vulnerabilities (and has no parameters for damage type), it assumes those have already been taken care of\n// second parameter is damage multiplier\n// common values\n// 1 for normal damage\n// 0.5 for half damage\n// -1 for healing\nthis.actor.applyDamage(hpValue, -1);\n\nChatMessage.create({\n user: game.user._id,\n speaker: ChatMessage.getSpeaker({token: this.actor}),\n content: `Gained ${hpValue} Temp HP and healed ${hpValue} HP`\n});","folder":null,"sort":0,"flags":{"core":{"sourceId":"Macro.RfaQqaCMNbu1Q6yo"}},"ownership":{"default":0,"MZbxT6Tw0ZjDJstw":3},"_stats":{"systemId":"dnd4e","systemVersion":"0.3.3","coreVersion":"10.285","createdTime":null,"modifiedTime":1663419236079,"lastModifiedBy":"MZbxT6Tw0ZjDJstw"}}
{"name":"Item: Set Condition on Actor","type":"script","author":"MZbxT6Tw0ZjDJstw","img":"icons/magic/perception/silhouette-stealth-shadow.webp","scope":"global","command":"// Sets a status effect on a token that is controlled by the running actor\n// this is designed to be used as an item macro, when your power does something to the PC that you want to track\n// e.g. a druids wild shaping, or that a character has increased defences\n\nconst effectId = \"drunk\"\n\n// should only be tokens in current scene\nconst tokens = this.actor.getActiveTokens();\n\n// All PC tokens link back to parent actor, so only need to poke one of them\n// If you want this to work for multiple tokens for monsters then change this to a for loop\nif (tokens.length > 0) {\n  const token = tokens[0];\n  const condition = CONFIG.statusEffects.find((effect) => effect.id === effectId);\n  if (!condition) return;\n  token.toggleEffect(condition, {active: true})\n}","folder":null,"sort":0,"flags":{"core":{"sourceId":"Macro.KxORyVXVsLaRyTnJ"}},"_id":"xpis8v8yeYd532Pk","ownership":{"default":0,"MZbxT6Tw0ZjDJstw":3},"_stats":{"systemId":"dnd4e","systemVersion":"0.3.3","coreVersion":"10.285","createdTime":null,"modifiedTime":1663419278720,"lastModifiedBy":"MZbxT6Tw0ZjDJstw"}}
